package com.cellngine.crypto;

/**
 * Provides a simple synchronized implementation of the Rivest cipher 4 random number generator and
 * encryption scheme.
 *
 * @author qwertty <hellraz0r.386@googlemail.com>
 */
public class RC4 implements StreamCipher
{
	public static final int	SKIP_BYTES	= 1024;

	private int				a			= 0;
	private int				b			= 0;
	private final int[]		s			= new int[256];

	/**
	 * Initialises the RC4 S-Box, thus preparing the algorithm to allow it to produce pseudo-random
	 * numbers. As the first few bytes of RC4's PRNG output leak information about the original key
	 * (see "<i>Weaknesses in the Key Scheduling Algorithm of RC4</i>" by Scott Fluhrer, Itsik
	 * Mantin and Adi Shamir), {@link RC4#SKIP_BYTES} of random data are automatically
	 * generated and discarded once the PRNG is ready.
	 *
	 * @param seed
	 *            The seed to initialise the RC4 PRNG with.
	 * @throws IllegalArgumentException
	 *             If the key length is invalid (smaller than 1 or larger than 256).
	 */
	public RC4(final byte[] seed)
	{
		if (seed.length < 1) { throw new IllegalArgumentException("RC4 Key too short (minimum: 1 byte)"); }
		if (seed.length > 256) { throw new IllegalArgumentException("RC4 Key too long (maximum: 256 bytes)"); }

		for (int i = 0; i < 256; i++)
		{
			this.s[i] = i;
		}
		for (int i = 0; i < 256; i++)
		{
			this.b = (this.b + this.s[i] + this.byte2int(seed[i % seed.length])) % 256;
			this.swap(this.b, i);
		}
		this.b = 0;

		for (int i = 0; i < RC4.SKIP_BYTES; i++)
		{
			this.getByte();
		}
	}

	/**
	 * @return A single pseudorandom <code>byte</code> generated by the RC4 PRNG.
	 */
	private byte getByte()
	{
		// a = (a + 1) % 256;
		// b = (b + s[a]) % 256;
		this.a++;
		this.a %= 256;

		this.b += this.s[this.a];
		this.b %= 256;

		this.swap(this.a, this.b);
		return (byte) this.s[(this.s[this.a] + this.s[this.b]) % 256];
	}

	/**
	 * Applies the RC4 encryption scheme by XOR'ing the input with data from the RC4 PRNG.
	 *
	 * @param input
	 *            The plain- or ciphertext that shall be en- or decrypted.
	 * @return The result of the XOR operation.
	 * @throws <code>NullPointerException</code> if <code>input</code> is <code>null</code>.
	 */
	private byte[] crypt(final byte[] input)
	{
		if (input == null) { throw new NullPointerException(); }
		if (input.length == 0) { return new byte[] {}; }

		final byte[] output = new byte[input.length];

		for (int i = 0; i < input.length; i++)
		{
			output[i] = (byte) (input[i] ^ this.getByte());
		}

		return output;
	}

	@Override
	public byte[] encrypt(final byte[] input)
	{
		return this.crypt(input);
	}

	@Override
	public byte[] decrypt(final byte[] input)
	{
		return this.crypt(input);
	}

	/**
	 * Swaps the values of two elements in the S-Box.
	 */
	private void swap(final int x, final int y)
	{
		final int temp = this.s[x];
		this.s[x] = this.s[y];
		this.s[y] = temp;
	}

	/**
	 * Converts an unsigned byte to an integer. (e.g. 0xff would be converted to 255)
	 */
	private int byte2int(final byte toInt)
	{
		return toInt & 0xff;
	}
}
